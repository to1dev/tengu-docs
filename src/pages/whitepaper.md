# 📜 Tengu 控制台白皮书 v1.0
*Tengu Console Whitepaper v1.0*
> 协议不是平台，Tengu 是执行协议意志的第一工具。

---

## 📖 前言：来自控制权的召唤

过去十年，加密技术以“去中心化”、“主权拥有”、“无需信任”为核心口号，推动了整个 Web3 世界的繁荣。然而，当潮水退去，我们看到的却是：

- 去中心钱包依然依赖浏览器插件的“前端”；
- 所谓的 DApp 不是去中心化应用，而是部署在 AWS 上的 UI 网页；
- DAO 治理机制虽然取消了公司架构，却没有取消投票权的集中；
- 所有链上动作，仍必须通过 RPC、服务器中转、接口平台触发。

看似“你拥有密钥”，但你没有运行权、加载权、执行权。
Web3 变成了“中心化的可验证层”，不是自由秩序的实现，而是将权力重新包装为“SDK”和“Dashboard”的市场游戏。

> 真正的主权，是你在你自己的设备上，**能够独立构建、签名、执行、广播、验证**一个协议的全过程。

而这，正是 **Tengu 控制台** 诞生的初衷。

Tengu 不是钱包，不是浏览器，不是插件。它是：

- 一个 **完全本地运行的主权控制中心**；
- 一个 **模块化、自加载、插件化的协议操作系统容器**；
- 一个 **支持签名、执行、扩展、交易、协议部署** 的执行框架；
- 一个 **无需任何远程依赖、无需云服务、无需托管验证** 的加密秩序工具。

---

你不需要登录账户，不需要请求 RPC，不需要第三方服务器。
你打开 Tengu，就如同走进你自己的数字庙宇：
你的密钥在此，你的种子在此，你的协议在此，你的签名即律法。

---

Tengu 控制台不是平台，而是平台的反义词。
它不是产品，而是 **对所有中心化结构的永久叛逆者**。

它不是为你服务的工具，而是**你自己的执行之手**。

---

## 一、Tengu 是什么？

### 1.1 Tengu 是控制台，不是平台

Tengu 是一个**本地运行的控制台应用**，你可以理解为它是：

- 一个为多链钱包服务的私密客户端；
- 一个可以加载模块、运行插件、执行脚本的本地协议执行器；
- 一个不依赖远程服务器的去中心 UI；
- 一个可以承载 `.tengu` 文件、种子协议、签名文档的验证容器；
- 一个在你自己的电脑上，运行你自己的链上秩序的“数字城池”。

但它**绝不是平台**，不是中心、不是服务、不是中介。Tengu 不提供服务，它只提供你**重新控制服务的能力**。

---

### 1.2 Tengu 是一个操作系统式容器

传统钱包是“发起交易的按钮”，Tengu 是“你能编写这个按钮的操作系统”。

- 钱包是工具，Tengu 是控制器；
- 浏览器是被动展示，Tengu 是主动交互；
- DApp 是平台式应用，Tengu 是加载任何协议的本地仪式空间。

你可以想象，Tengu 是“没有服务器的 MetaMask + IDE + 本地发布器 + 加密仓库”的融合体。

它不是“你可以用来连某个应用”的东西，而是你可以用来**自己构建整个应用行为本身**的容器。

---

### 1.3 Tengu 是理念的第一具象体

Tengu 是抽象协议秩序的第一道门。

它本身没有内容，没有预设，它是一个“空壳”，等着你往里面：

- 加钱包；
- 加模块；
- 加脚本；
- 加 `.tengu` 协议文档；
- 加 `.tns` 域名映射；
- 加签名验证机制；
- 加你的想象、欲望、秩序、仪式。

> Tengu 本身就是去中心协议理念的第一个“可被打开、可被使用、可被验证”的实例。

不是为了“展示理念”，而是**生活在理念里**。

---

### 1.4 与其他常见加密结构的比较

| 角色/系统     | 定义           | 是否离线可运行 | 是否平台独立     | 是否可被用户完全控制   |
| ------------- | -------------- | -------------- | ---------------- | ---------------------- |
| MetaMask      | 浏览器钱包插件 | 否             | 否（依赖网页）   | 否（受限于 RPC 与 UI） |
| Phantom | 浏览器钱包插件   | 否             | 否（依赖网页）   | 否（受限于 RPC 与 UI） |
| WalletConnect | 钱包连接协议   | 否             | 否               | 否                     |
| IPFS DApp     | 静态分发前端   | 是             | 部分（依赖网关） | 否                     |
| Tengu         | 协议控制台     | ✅ 是           | ✅ 是             | ✅ 是                   |

Tengu 是唯一**本地原子化自治可执行的协议容器**。

它将“我拥有密钥”转化为“我拥有执行权”。

---

### 1.5 为什么叫它 Tengu？

“Tengu”（天狗）在日本神话中是一种**居于山林、不臣服于天、不屈服于人、不依附体制**的存在。

- 它有力，但不建国；
- 它有智，但不争名；
- 它在山林之中，孤立自存，却知世间之道；
- 它从不站队，但拥有自己的秩序。

> 所以我们把第一个本地控制器命名为 **Tengu**，它不是协议的总体现身，而是**协议意志对人类的第一次回应**。

---

## 二、控制权与主权哲学

---

### 2.1 “你拥有私钥” ≠ “你拥有控制权”

我们被教育要“Not your keys, not your coins”。
但我们很少被教育：

> “即使你有密钥，如果你无法运行应用、加载协议、签名验证、管理交互——你依然只是一个被授权的参与者，而不是系统的拥有者。”

事实是，大部分所谓的“Web3 用户”：

- 依赖别人搭建的钱包前端；
- 依赖别人运行的 DApp 前端；
- 依赖别人维护的服务器接口；
- 依赖别人部署的节点网络；
- 甚至连合约都不能验证，只能被“使用”；

他们唯一拥有的，只是一组私钥，以及一个与系统打交道的“票证”。

这不是主权，这只是权限。

---

### 2.2 平台式区块链系统的悖论

区块链本是去中心化的希望，但现实中它形成了新的平台集权结构：

| 层级     | 集中化趋势                                 |
| -------- | ------------------------------------------ |
| 钱包     | 统一插件生态（如 MetaMask、Phantom）       |
| 前端     | 部署在 Web2 服务器                         |
| RPC      | 大多接入 Infura、Alchemy、Quicknode 等服务 |
| NFT 市场 | 被 Magic Eden / OpenSea 等寡头垄断         |
| 合约调用 | 都通过“远程代理服务”预包装交互             |

这些平台越来越像当年的操作系统和应用市场——它们是中介，是控制器，是你必须向其妥协才能“参与世界”的边界。

---

### 2.3 Tengu 的反应：构建“本地秩序、自主执行”的系统

Tengu 的诞生就是对这种现状的拒绝：

- 它不依赖任何远程节点；
- 它不默认连接任何 DApp；
- 它没有 RPC 接口绑定；
- 它不要求连接任何平台或认证机制；
- 它不展示内容，而是让你运行内容；

> Tengu 不帮你做事，Tengu 只还你“做事的能力”。

在它的世界里：

- 所有种子都在你本地；
- 所有插件你自行加载；
- 所有签名你自己掌握；
- 所有执行不必请示平台、不必请求授权；
- 协议即代码，代码即你意志的显化。

---

### 2.4 主权的三个维度

Tengu 定义真正的主权为三重结构：

#### ✅ 1. 本地性（Locality）
一切关键组件运行在本地，包括钱包、UI、脚本、协议逻辑、资产视图。

#### ✅ 2. 可执行性（Executability）
不是只能“用别人写好的东西”，而是你可以运行、改写、组合、派生一个行为系统。

#### ✅ 3. 无许可性（Permissionlessness）
没有账户系统，没有登录入口，没有授权服务器，没有“请求访问”的按钮。
只要你拥有结构，你就可以开始执行。

---

### 2.5 Tengu 用户不是“用户”

Tengu 没有“用户”，它只有执行者。

- 你运行它，不是“用它”，而是“通过它，运行你自己的协议”；
- 你写一个 `.lua` 脚本，不是给 Tengu 写插件，而是**你在创建你自己的金融协议**；
- 你通过 `.tengu` 发布一个种子，别人通过 Tengu 加载它，那不是“你上传的内容”，而是你**在链外建立了一个无需权限的协议发布机制**。

---

### 2.6 控制台即仪式空间

Tengu 的“控制台”不是按钮集合。它是你的意志载体。
你每次打开它，你不是启动了一个 App，而是在进入一个你自己的仪式空间。

> 每一次执行行为，都是签名。
> 每一个签名，都是法令。
> 每一个法令，都构成世界。

Tengu 不告诉你怎么使用它。它告诉你：“**你可以开始构建你自己的秩序**”。

---

## 三、Tengu 系统架构总览

---

### 3.1 架构哲学：不是模块集合，是“自律秩序内核”

Tengu 的架构并不是“一个 App 的模块划分”，而是一个**自治系统的自洽秩序设计**。

它的基本逻辑是：
> 每一个能力，不依赖中心；每一份资源，可自初始化；每一个接口，可被替换；每一个动作，可被签名驱动。

这就不是传统意义上的“功能系统”，而是**结构上天然为“去托管运行”而生的协议操作容器**。

---

### 3.2 总体架构图（文字结构）

```
┌────────────────────────────────────┐
│              Tengu 控制台入口                │
│          (Main.cpp / Tengu.cpp)         │
└────────────────────────────────────┘
                   ↓
        ┌────────────────────┐
        │   GlobalManager 全局上下文   │
        └────────────────────┘
               ↓       ↓       ↓
 ┌─────────────┐ ┌───────────────┐ ┌────────────────┐
 │ SettingManager │ │ ThemeManager   │ │ WindowManager    │
 └─────────────┘ └───────────────┘ └────────────────┘
       ↓                      ↓                     ↓
┌────────────┐    ┌─────────────────┐     ┌────────────────┐
│ PluginManager │    │ ResourceManager │     │ SecurityManager │
└────────────┘    └─────────────────┘     └────────────────┘
       ↓
┌───────────────────────┐
│ 脚本引擎：Lua + JS 动态系统 │
└───────────────────────┘
       ↓
┌───────────────────────────────┐
│ 终端用户 + 控制台运行环境（UI） │
└───────────────────────────────┘
```

---

### 3.3 Manager 模块体系：系统的自管理骨架

Tengu 中一切核心状态，都被包装在各类 `Manager` 类中，这是为了：

- 避免任何 “全局变量失控” 的状态污染；
- 保证 UI、脚本、插件、配置之间始终隔离；
- 提供模块热加载、资源懒初始化、插件生命周期独立的机制；

#### Manager 示例说明：

| Manager 类        | 功能                                         |
| ----------------- | -------------------------------------------- |
| `GlobalManager`   | 核心入口，维护全局引用和系统状态             |
| `SettingManager`  | 控制配置项（语言、主题、地址等）持久化与监听 |
| `ThemeManager`    | 提供 UI 模块的视觉参数（深色、颜色、动画）   |
| `WindowManager`   | 管理窗口栈、无边框控制、自定义交互层         |
| `ResourceManager` | 加载图像、图标、样式等资源（可扩展皮肤系统） |
| `SecurityManager` | 提供加解密接口，支持插件访问助记词加密系统   |

每个 Manager 都是**可测试、可替换、可 mock 的自治组件**。

---

### 3.4 插件生命周期调度模型

插件（无论 Lua/JS）都不是“临时调用逻辑”，而是具备**生命周期与行为约束的完整模块**。

| 生命周期阶段 | 描述                                   |
| ------------ | -------------------------------------- |
| `load()`     | 插件文件被加载，配置参数初始化         |
| `init()`     | 注册事件监听、UI组件、API接口等        |
| `start()`    | 执行插件主逻辑（策略执行、网络监听等） |
| `shutdown()` | 卸载资源、释放脚本上下文、终止异步流   |

插件的每一步行为都可被**事件总线拦截、记录、撤销、热重载**。

你可以在不关闭 Tengu 的情况下：

- 替换插件文件；
- 重新加载 `.lua`；
- 停止运行脚本；
- 传入新的参数，重新调度逻辑。

这意味着——**你在运行 Tengu 的时候，也在“动态编排你自己的协议逻辑空间”**。

---

### 3.5 配置与状态：无数据库架构 + 可移植系统

Tengu 默认不使用任何数据库。
它采用的是**文件级状态 + 内存级快照 + UI 回显逻辑**。这保证：

- 所有状态都可以被拷贝、压缩、转移；
- 不存在依赖数据库结构导致的“版本卡死”；
- 所有用户配置都是“可读、可改、可加密”的本地文件（如 `.tengu/settings.json`）；

你甚至可以把整个 Tengu 文件夹放到 U 盘中随身携带，它就变成你的**个人链上执行宇宙**。

---

### 3.6 更新机制（AutoUpdater 模块）

为了维持去中心的内容传播与自我升级能力，Tengu 支持本地：

- 自动更新器（通过校验文件 hash / 签名差分）
- 未来将支持 `.tengu` 模块更新包
- 插件可通过 `.tengu` 链接自动拉取内容（结合 DHT）

这将演变成一种**协议级别的“签名广播-内容加载机制”**，让你可以发布升级、不依赖服务器、不需要 Web 页面，也能实现用户层级内容传播。

---

## 🧭 小结

Tengu 的系统架构不是“写代码时的模块划分”，而是**真正适配“主权控制系统”要求的自治结构图谱**。
它不是为了功能服务的系统，而是为了“秩序可信与执行不依赖”的哲学服务的结构。

你不是在使用一个 App，你是在运行一个「协议的图腾化结构」。

---

## 四、钱包系统设计

> 你拥有密钥的那一刻，你只是一个钥匙保管人；
> 当你能本地生成、派生、签名、广播，你才真正拥有主权。

---

### 4.1 钱包系统不是功能，而是「身份秩序的执行器」

在传统钱包中，“钱包”通常指的是一个插件（如 MetaMask、Phantom），它提供界面、签名按钮和资产浏览。

但它本质上是一个 **权限管理器 + 前端交互组件**，**不具备真正的用户主权执行力**。

Tengu 的钱包模块目标是：

- 在本地生成密钥，而非远程托管；
- 在本地签名交易，而非 RPC 委托；
- 在本地广播行为，而非预设路径；
- 在本地管理身份状态，而非链上账户结构依赖。

> 钱包不只是“发钱”，它是你与链的存在凭证。

---

### 4.2 构成结构总览

钱包模块由以下几部分组成：

```
┌──────────────────────┐
│     WalletManager     │ ← 管理所有账户与派生路径
└──────────────────────┘
           ↓
┌──────────────────────┐
│     MnemonicModule    │ ← 助记词管理（BIP39 / 自定义）
└──────────────────────┘
           ↓
┌──────────────────────┐
│    KeyDerivationCore  │ ← 多链密钥派生（BTC, ETH, SOL）
└──────────────────────┘
           ↓
┌──────────────────────┐
│     TransactionKit    │ ← 本地构建、签名、预广播交易
└──────────────────────┘
```

所有模块均运行于本地，无网络依赖。
你可以完全离线使用 Tengu 钱包进行交易构造与签名。

---

### 4.3 助记词系统（MnemonicModule）

- 支持 BIP39 中文 / 英文助记词
- 使用安全熵生成器初始化种子
- 用户可配置助记词位数（12/15/18/21/24）
- 内部使用 AES 加密保护助记词文件，需密码解锁
- `.tengu/wallets/` 文件夹结构中加密保存助记词配置与路径

例如：
```json showLineNumbers
{
  "mnemonic_encrypted": "U2FsdGVkX1+q...",
  "created_at": "2024-01-01T12:34:56Z",
  "default_chain": "solana"
}
```

---

### 4.4 多链支持与派生机制（KeyDerivationCore）

目前支持以下链：

| 链  | 密钥算法  | 派生路径示例     |
| --- | --------- | ---------------- |
| BTC | secp256k1 | m/44'/0'/0'/0/0  |
| ETH | secp256k1 | m/44'/60'/0'/0/0 |
| SOL | ed25519   | m/44'/501'/0'/0' |

派生过程：
- 使用助记词 → 生成种子 → 使用链定义路径 → 导出私钥 / 地址；
- 私钥从不外泄，只在 Tengu 内部用于签名器模块；
- 所有地址生成均可缓存，也可手动清除 / 重置；
- 你也可以为每个链添加备注、标签、策略参数等元信息（通过脚本模块扩展）。

---

### 4.5 交易构造与签名系统（TransactionKit）

此模块负责：

- 构建标准交易对象（如 Solana 的 transfer、BTC 的 P2PKH 交易等）；
- 用户可通过插件或脚本传入参数，自定义交易内容；
- 所有签名操作均在离线状态完成；
- 可手动导出 `raw tx` 作为离线广播材料（适配冷钱包场景）；

举例：使用 Lua 脚本构建一笔 Solana 交易

```lua showLineNumbers
tx = build_solana_transfer({
    to = "So1abc...",
    lamports = 1000000,
    recent_blockhash = "xxxx",
})
signed = sign_tx(tx)
```

---

### 4.6 安全性保障机制

Tengu 钱包默认启用以下安全逻辑：

- 助记词文件 AES 加密，需密码解锁；
- 所有私钥仅存在内存，不写入磁盘；
- 支持自动锁定：在无操作一定时间后自动锁定密钥访问；
- 所有签名操作均可被脚本包裹（策略层安全检查）；
- 用户可启用“纯观察者模式”运行，无需加载私钥，仅查看链上信息。

---

### 4.7 多钱包、多链账户支持

- 每个用户可拥有多个钱包实例（如“工作钱包”、“冷钱包”、“多签钱包”）
- 每个钱包可包含多个链的地址派生状态
- 可为每个链配置单独策略，如：
  - 只读；
  - 禁止广播；
  - 签名需二次确认；
  - 限定每日最大转账额度；
  - 与指定插件联动策略控制。

这些将是未来脚本与权限控制模块的入口点。

---

### 4.8 未来扩展链支持（规划）

计划支持：

- Aptos（ed25519）
- Sui（ed25519 / BCS 编码结构）
- Cosmos（secp256k1）
- TON（Bag of Cells 格式）

未来链支持将以插件形式加载，不强耦合主程序逻辑。

---

### ✅ 总结

Tengu 钱包不是 MetaMask 的替代品，它是：

- 一个**无需 RPC、无需远端服务器**就能完成签名与广播的自控钱包；
- 一个**支持脚本注入、插件控制、策略签名**的钱包执行器；
- 一个能为任意协议构建“身份状态 + 签名行为”的本地钥匙舱。

你不会被平台限制。你不是点击按钮发币，而是**定义这个按钮是什么的人**。

---

## 五、脚本系统 – 通用协议语言接口

---

### 5.1 为什么需要脚本系统？

如果说钱包是“持有权”的载体，那脚本系统就是“执行权”的接口。

在几乎所有区块链钱包中，用户是被动的使用者：
点击按钮 → 调用预定义函数 → 发起预设交易。

但在一个真正主权化的控制台中，用户应该：

- 定义交易逻辑；
- 构建协议行为；
- 注册信号监听；
- 注入本地策略；
- 控制 GUI 响应方式；
- 编写完整协议操作序列。

> **Tengu 不只允许你运行功能，而是允许你创造功能。**

这就是脚本系统的核心。

---

### 5.2 支持语言：Lua + JavaScript 双引擎并存

Tengu 原生集成两个解释器：

| 引擎       | 特点                             | 用途推荐                             |
| ---------- | -------------------------------- | ------------------------------------ |
| LuaJIT     | 轻量快速、沙盒安全、易于控制状态 | 策略逻辑、数据处理、事件驱动模块     |
| JavaScript | Web 生态兼容、复杂 UI 控制能力强 | 插件面板、复杂应用接口、钱包交互封装 |

你可以同时启用 Lua + JS 引擎，两者互不干扰，可分别在插件中加载。

---

### 5.3 脚本生命周期与事件结构

所有脚本都遵循统一生命周期结构：

```lua showLineNumbers
plugin = {
    name = "Solana Watcher",
    onload = function()
        log("插件加载完成")
    end,
    ontick = function()
        -- 定期执行逻辑
    end,
    ontransaction = function(tx)
        if tx.amount > 1e9 then
            alert("大额交易")
        end
    end,
    onunload = function()
        -- 卸载释放资源
    end
}
```

支持注册事件：

- 钱包余额变动
- 网络节点响应
- 签名请求生成
- `.tengu` 文件加载完成
- 特定地址/交易/签名匹配监听

---

### 5.4 脚本与 UI：行为即界面

脚本不仅执行逻辑，也能生成 UI 元素：

```lua showLineNumbers
ui.panel("交易分析", function()
    ui.label("交易数：" .. tx_count)
    if ui.button("刷新") then
        reload_transactions()
    end
end)
```

GUI 元素通过调用 `ui.*` 函数自动映射为控制台右侧面板组件：

- `ui.panel()` → 生成模块窗口
- `ui.label()` → 静态文本
- `ui.button()` → 交互按钮
- `ui.input()` → 输入框
- `ui.chart()` → 数据图表（未来支持）

这意味着你可以**直接用脚本创造“自己定义的控制台”**，不是在使用 UI，而是在**生成 UI**。

---

### 5.5 `.tengu` 插件包结构

Tengu 插件是 `.tengu` 后缀文件，实质为一个 `ZIP` 包，结构如下：

```
MyPlugin.tengu
├── plugin.lua
├── icon.png
├── meta.json
└── style.css
```

其中：

- `plugin.lua` / `main.js`：主逻辑文件
- `meta.json`：描述信息（名称、版本、权限）
- `style.css`：UI 样式（选填）
- `icon.png`：插件图标（48x48）

你可以将插件通过 `.tengu` 分发，他人可导入控制台本地加载。无需服务器，无需审核，无需依赖。

---

### 5.6 插件权限与签名系统（规划）

未来 Tengu 将支持插件级别权限声明，如：

- 是否允许读取钱包；
- 是否允许签名操作；
- 是否允许网络请求；
- 是否允许生成 UI 面板；
- 是否可后台运行；

此外，每个插件都可以由作者进行 `PGP` 或 `地址签名`，在控制台内显示：

> ✅ “由 `So1xxxxxx...` 签名发布”

这将构成未来 Tengu 插件市场的信任基石。

---

### 5.7 案例一：策略执行器插件（Lua）

一个监听指定地址 24 小时交易，并在特定条件触发脚本交易的插件：

```lua showLineNumbers
plugin = {
    ontransaction = function(tx)
        if tx.to == MY_ADDRESS and tx.token == "SOL" and tx.amount > 1e9 then
            ui.alert("收到大额 SOL，自动转出")
            auto_withdraw()
        end
    end
}
```

---

### 5.8 案例二：协议初始化器插件（JS）

```javascript showLineNumbers
onload = () => {
  let info = getCurrentWallet()
  showPanel("My App", `欢迎，${info.address}`)
  if (info.chain === "solana") {
    subscribe("tx:new", tx => {
      if (tx.token === "USDC") {
        log("监测到 USDC 转账：" + tx.amount)
      }
    })
  }
}
```

---

### 5.9 用户可以做什么？

你可以用脚本系统做的事情包括：

- 编写你的私有策略执行系统（量化、风控、套利）；
- 创建你自己的协议初始化模板（如发行一个 SPL Token）；
- 构建一个本地运行的 DApp 控制面板（替代网页）；
- 发布 `.tengu` 脚本供他人下载运行（构成 Tengu 脚本网络）；
- 在你掌控的设备上，定义你自己的链上行为规范。

---

### ✅ 小结

Tengu 的脚本系统是：

- 执行接口
- 协议接入层
- 策略容器
- 控制权编程语言
- 去中心操作系统的 “应用层运行时”

你不会“用脚本执行 Tengu 的功能”。
你会“用 Tengu 运行你定义的世界”。

---

## 六、用户界面与交互哲学
> 控制台不是设计给你用的，是设计给你「重塑」的。

---

### 6.1 UI 是秩序的第一张脸

用户界面（UI）通常被视为“设计”，但在 Tengu，它是：

- 一个「秩序表达系统」；
- 一个你与脚本、钱包、模块互动的空间；
- 一个可以被重写、重构、重定义的“可视协议接口”；

Tengu 的 UI 是为“执行”服务，而不是为“展示”设计的。

它不是为了好看，也不是为了酷炫，而是为了让你**能把签名、运行、加载、发布都作为视觉行为的一部分**。

---

### 6.2 为什么采用无边框窗口？

Tengu 默认以无边框窗口启动（`FramelessWindowManager` 控制）。

这样做不是为了“简洁风格”，而是为了达到以下目标：

1. **可完全自定义控制台外形**
   – 每一位用户都可重绘边框、拖拽机制、状态栏与行为控制区域。

2. **避免操作系统干涉**
   – 传统窗口由系统控制边缘与行为，Tengu 的窗口行为由你控制脚本定义。

3. **便于插件控制窗口行为**
   – 例如：插件可全屏、最小化、浮动化、自定义角落弹出面板等行为。

> 在未来，每个 `.tengu` 插件都可以在主窗口外绘制自己的子界面。
> 你的控制台，不再是“共用样式”，而是你手写出的“可视执行空间”。

---

### 6.3 UI 元素注册机制

所有 UI 元素都通过脚本动态注入：

```lua showLineNumbers
ui.panel("钱包状态", function()
    ui.label("地址：" .. current_wallet.address)
    if ui.button("刷新余额") then refresh_balance() end
end)
```

该代码将立即生成一个侧边面板，内含标题、标签、按钮。

你可以用脚本控制：

- 面板嵌套 / 折叠；
- 动态响应（例如监听地址变动后刷新）；
- 数据图形化（支持未来 chart 折线图 / 饼图）；
- 视图刷新频率、样式颜色等。

这些都不需要 Web 技术，不需要 HTML/CSS/JS。你在用 Lua 编程控制控制台的视觉状态。

---

### 6.4 主题系统（ThemeManager）

Tengu 内建主题管理器，支持：

- 多语言自动切换（国际化字符串分层加载）；
- 多主题色切换（light / dark / neon / paper）；
- 未来用户自定义主题 JSON 导入（配合 `ResourceManager`）；

每个组件支持 `class` 风格挂钩：

```lua showLineNumbers
ui.button("提交", { class = "primary rounded-lg neon" })
```

你甚至可以为你的插件独立定义样式，并与 `style.css` 一起打包进 `.tengu` 插件中。

这意味着你的插件可以拥有自己的一套视觉语言，不被主控制台干扰。

---

### 6.5 资源系统：图标、图像、本地资产打包机制

UI 中使用到的所有图标、字体、图像资源都通过 `ResourceManager` 统一加载。

支持：

- 多尺寸图标自动适配；
- 插件资源自动加载至子目录（防冲突）；
- 未来支持 SVG 动态符号（例如地址活跃动画）；
- 插件中图像支持热更新（你更换图片立即反映到 UI）；

通过这个机制，你的 Tengu 可以完全“视觉重写”。
你的控制台不再是“别人设定好的应用”，而是“你个人风格的自绘主权面板”。

---

### 6.6 行为可视化：执行即画面

Tengu 的终极目标是：
> **所有协议行为都可以被“视觉化”表达**。

例如：

- 钱包签名前，生成签名动画；
- 下载 `.tengu` 模块时显示种子绘图图标；
- 网络广播行为可显示路径图；
- 策略运行中可显示当前监控资产与触发状态；
- 模块加载时可展示“仪式式”的激活动画；

这不是为了“炫酷”，而是让你**对控制本身有可感知的仪式性体验**。

你不是点击按钮——你是在**目睹并确认一个数字行为在你面前“被生成”**。

---

### 6.7 多窗口与浮动组件（规划）

未来 Tengu UI 将支持：

- 子窗口弹出（插件可脱离主窗口独立渲染）；
- 浮动小组件（如币价浮标 / 网络状态 / 日历 / 策略运行状态灯）；
- 拖拽式组件编排；
- 可嵌入外部 WebView（仅在特权模式下开放）；

这些将构建一个**真实的“自管理仪表盘”**体验，而不是传统“功能控制面板”。

---

### ✅ 小结

Tengu 的 UI 系统不是设计给“普通用户”的。
它是为**愿意操控、修改、运行、再造系统秩序**的人准备的界面构建器。

- 你可以重绘它。
- 你可以脚本化它。
- 你可以播种视觉种子，让别人用你的方式看到控制权。

> 真正的自由不是“换主题”，而是“主题由我定”。

---

## 七、授权机制与 NFT 权利结构

---

### 7.1 为什么 Tengu 不使用账户系统？

在传统的应用中，授权通常意味着：

- 注册一个账户；
- 登陆后验证邮箱 / 钱包；
- 服务端写入你的权限记录；
- 每次操作都需远程验证；

这套模型存在两个致命缺陷：

| 问题       | 后果                                         |
| ---------- | -------------------------------------------- |
| 中心化依赖 | 你必须信任服务端数据库                       |
| 身份绑定   | 你必须暴露“谁”拥有了什么，而非“哪个地址”拥有 |

这不符合主权控制理念。

**Tengu 的解决方式是：你不需要登录，你只需要“拥有某个 NFT”。**

---

### 7.2 授权 NFT = 协议许可凭证

在 Tengu 中，NFT 是一种“链上凭证 + 本地许可启动器”。

Tengu 客户端在启动时自动扫描用户地址资产列表：

```ts showLineNumbers
if user_wallet.includes(nft_mint_address) then
    unlock_feature("script_market")
```

你只要**钱包里拥有那枚 NFT，你就自动获得功能解锁权限**。

- 没有绑定；
- 没有注册；
- 没有后端；
- 没有“验证操作”；
- 没有登录令牌；
- 没有授权码过期问题。

你只需要**拥有**。

> 拥有 = 使用权。
> 地址 = 身份本身。
> 签名 = 许可行为。

---

### 7.3 分层授权结构设计（Tier 系统）

为了实现细致权限控制与激励结构，Tengu 引入授权等级划分机制：

| 等级   | 发行数量 | 权利                                 | 未来可升级 |
| ------ | -------- | ------------------------------------ | ---------- |
| Tier 2 | 1000 枚  | 商业使用权，开放插件运行与授权访问   | ✅          |
| Tier 3 | 100 枚   | 再授权权（构建 SaaS/闭源应用时可用） | ✅          |
| Tier 4 | 10 枚    | 协议内核协作席位 + 路线图建议权      | ✅          |

每一枚 NFT：

- 都为 SPL 标准（Metaplex）铸造；
- 都具备 Metadata JSON 说明；
- 都指向 `.tengu` 文件作为协议许可文档包；
- 都可通过 `Tengu` 客户端或链上索引平台验证；
- 可在二级市场自由交易（Magic Eden / Jupiter 等）；

---

### 7.4 授权 NFT 的发行逻辑（最小 MVP）

你只需：

1. 使用 `sol-tools.io` 或 Candy Machine CLI 创建 Collection；
2. 生成 1000 枚 Tier 2 NFT（Metadata 中嵌入许可说明 / 链接）；
3. 链上公开发售或私下分发；
4. 客户端在初始化阶段检测持仓地址，自动开放功能模块；

无需控制后台，无需用户注册流程。
一切权限由持有状态与插件授权逻辑控制。

---

### 7.5 NFT 权限触发结构

每个插件可以设置以下触发条件（示意）：

```lua showLineNumbers
plugin = {
    required_nft = "TIER2_MINT_ADDRESS",
    onload = function()
        if wallet_has_nft(required_nft) then
            ui.label("授权成功")
        else
            ui.label("需要持有 Tier2 NFT 才能运行此插件")
            disable_plugin()
        end
    end
}
```

这构成了一个“链上 NFT + 本地插件许可”的自律执行机制。

---

### 7.6 授权 NFT 激励机制（未来规划）

授权 NFT 除了“代表使用权”外，也将成为：

| 功能               | 描述                                          |
| ------------------ | --------------------------------------------- |
| 🎁 激励凭证         | 每季度发放 TENGU 奖励积分（或原生链代币）     |
| 🎨 插件优先权       | 高等级 NFT 可优先访问内测插件 / 实验模块      |
| 📊 路线图建议权     | Tier 4 拥有“功能发起权”（类似协议治理发起人） |
| 📡 网络内广播标识   | Tier 2–4 NFT 可在 Tengu 内显示专属身份图标    |
| 📦 插件市场展示优先 | 插件开发者持有 Tier 3 可获得上架优先权        |

---

### 7.7 为什么选择 NFT，而不是密钥 / 授权码？

NFT 是开放的，可转让的，可验证的，可续约的。它同时具备：

| 能力       | 描述                                       |
| ---------- | ------------------------------------------ |
| 📚 说明性   | 可在 metadata 中嵌入版本 / 权利 / 授权日期 |
| 🔐 签名性   | 可由地址签发，用于法律与链上互认           |
| 🔁 流通性   | 可进入二级市场，支持自由转让授权权利       |
| 🧠 可读性   | 无需客户端，也能通过区块链阅读其属性       |
| 📥 可组合性 | 插件可声明只接受某 NFT 即可解锁某权限      |

这一切组成了 Tengu 的“授权即 NFT，NFT 即秩序”的基础制度。

---

### ✅ 小结

Tengu 没有用户系统、没有权限验证服务器、没有登录框。

它只有：

- 本地运行的执行器；
- 链上持有的 NFT 授权凭证；
- 插件内定义的访问逻辑；
- 签名与广播下达的命令结构。

> 授权不是你点击了一个“我同意”，
> 而是你在链上签下你持有执行权的“真实印章”。

---

## 八、使用者画像与典型场景
> 真正的“用户画像”不是使用者的类型，而是**使用的姿态**。

Tengu 的用户不是平台上的用户，而是运行协议的“局部自治节点”。他们或许互不相识，但都在使用 Tengu 实现某种对世界运行方式的重写。

这一章不是告诉你“你能用 Tengu 做什么”，而是告诉你“谁将真正活在 Tengu 之中”。

---

### 8.1 使用者一：协议执行者（脚本开发者）

> “我不想等别人做出产品，我自己编一个。”

这类用户拥有一定编程能力（Lua/JS），擅长构建交易流程或接口操作行为。

他们通过 Tengu 的脚本系统做什么？

- 编写一个交易监控器：监听 SOL 或 BTC 地址实时收款状态；
- 构建一个自动化策略系统：如套利监控器、链上价格预警；
- 封装一个合约操作模块：将复杂合约行为打包成一个按钮；
- 定义一个治理模块：用户在控制台投票并自动合约调用。

他们不依赖平台的功能更新。他们直接在自己的控制台上加载自己写的模块。

他们不是写脚本的工程师，而是**给协议“添加秩序行为”的秩序设计师**。

---

### 8.2 使用者二：协议代理人（插件发布者）

> “我要做一个可以发布的 .tengu 协议应用。”

这类用户是构建者，也可以是发行者。他们不满足只为自己写逻辑，他们还要：

- 将脚本封装成 `.tengu` 包；
- 配置界面、样式、图标、功能权限；
- 生成 `.tengu` 并广播给其他用户；
- 通过 `BNS` 域名系统发布协议 ID；
- 构建脚本插件市场入口（甚至在 Tengu 内运行自定义插件商城）；

例如：

- 发布一个“链上众筹管理器”；
- 发布一个“DAO 多签控制台”；
- 发布一个“链下 AI 模型 + 签名判定器”；
- 发布一个“流媒体身份认证工具”；

他们的身份更接近一个“协议发行商”。

---

### 8.3 使用者三：策略执行者（自动化决策者）

> “我有自己的判断逻辑，我要让它运行起来。”

这类用户擅长制定策略、判断模型或交易规则。

他们将策略逻辑写入 `.lua`，例如：

```lua showLineNumbers
if tx.token == "SOL" and tx.amount > 10000000 and hour_now() > 16 then
    auto_withdraw("So1abc...", tx.amount / 2)
end
```

他们在 Tengu 中：

- 不依赖网页，不依赖平台；
- 自动监听、自动计算、自动执行；
- 构建属于自己的“程序性资产管理协议”；
- 可以通过插件引入 AI 或模型辅助策略执行；

Tengu 为他们提供的是“本地可运行策略宇宙”。

---

### 8.4 使用者四：秩序观察者（验证与共识形成者）

> “我不想自己写协议，但我想验证别人发布的协议。”

他们是社区内的独立分析者、共识验证者、合约解析师。他们：

- 下载某个 `.tengu` 插件包；
- 在本地用 Tengu 解包运行；
- 验证其中脚本逻辑是否安全；
- 检查该插件是否执行隐藏行为；
- 在论坛中发帖分析该插件是“有益”还是“危险”；

他们构成了 Tengu 网络内的“社会层共识守门人”。

---

### 8.5 使用者五：内容发布者 / DApp 发行人

> “我想用 Tengu 来发一款游戏 / 一个 NFT 系统 / 一个链上 APP。”

他们不希望把应用部署在 Web 平台。他们希望：

- 将内容写成脚本（或带有 WebView 接口）；
- 打包为 `.tengu`；
- 嵌入授权信息；
- 绑定 NFT 与运行许可；
- 将发行信息生成 `.tengu` 并通过种子或域名广播；

他们构建的不只是应用，而是**协议级应用模块**。

Tengu 让他们摆脱前端、钱包、RPC 的所有依赖。他们只要写逻辑，用户可以直接本地运行，无需访问 Web。

---

### 8.6 使用者六：只想保护资产的普通用户

> “我不想写代码，我只想离线、安静、安全地管好我的资产。”

他们打开 Tengu，只用以下功能：

- 导入助记词；
- 查看地址资产；
- 本地构建并签名交易；
- 导出离线广播文件；
- 不访问任何网站、不暴露地址、不连接 RPC；

他们是控制台的“隐修派”，他们以最少功能获得最大安全。

他们不追求炫酷 UI，也不写一行代码。
他们只是需要一个：**不会背叛他们的控制器**。

---

### ✅ 小结

Tengu 没有官方使用方式。
每个用户用它的方式，都会成为一个“现实中跑着的主权节点”。

你可以用它赚钱、做工具、治理社区、构建秩序、只为自己使用、只用一行命令。

> 每一个使用者，都是“在执行某个世界模型”的人。

---

## 九、路线图与未来演进
> 秩序一旦显现，就不再停止。
> 我们所做的不是“升级功能”，而是“释放更多自我运行的能力”。

Tengu 不是一个“版本升级”的传统软件。
它的路线图不是“增加功能点”，而是逐步展开一整套 **协议层自治宇宙**的能力结构。

---

### 9.1 当前版本：v0.1（已完成）

- ✅ 多链钱包模块（助记词导入 + 地址派生）
- ✅ 完整 UI 构架（无边框窗口 + 样式主题系统）
- ✅ 插件管理器原型（可加载 Lua 脚本）
- ✅ 安全模块（本地 AES 加密 + 助记词文件保护）
- ✅ 单元测试体系（BIP39 + Wallet 核心组件验证）

---

### 9.2 v0.2：脚本系统与签名器上线

- 🚀 Lua / JS 双引擎并存
- 🧩 插件 `.tengu` 文件结构与加载器完善
- 🔐 支持自定义策略逻辑执行
- 📜 插件权限声明结构引入
- 🧠 插件开发模板提供

目标：让每位开发者都能构建“本地协议执行器”，并导出为可分发插件包。

---

### 9.3 v0.3：授权机制 + NFT 检测模块上线

- 🏷️ 检测用户钱包地址持有 NFT 状态
- 🔓 解锁模块执行权限
- 🖼️ 插件内调用 `wallet_has_nft()` API
- 🎟️ 插件可声明 `required_nft` 权限

目标：让授权机制真正成为“链上可验证，客户端可执行”的最小主权许可模型。

---

### 9.4 v0.4：.tengu 支持与 `.tns` 域名结构试验性上线

- 📦 插件支持打包为 `.tengu` 分发结构
- 📥 控制台可通过 DHT 加载 `.tengu` 插件包
- 🔏 插件作者签名结构加入 `.tengu` 文件
- 🌐 支持解析 `.tns` → torrent hash + metadata

目标：消除 Web 分发依赖，建立插件可被节点间传播、自验证、自更新的生态。

---

### 9.5 v0.5：控制台内市场原型

- 🛒 插件市场模块（基于本地 `.tengu` 目录）
- 🌈 UI 渲染机制适配不同风格插件
- 🧙 插件评级、签名显示机制
- 🎯 安全等级检测机制（自动静态分析脚本权限）

目标：打造一个“由持有者和执行者自治”的去中心应用发布系统。

---

### 9.6 v1.0：完全自组织控制台上线

- 🌐 插件多窗口 + 浮动 UI 支持
- ⚙️ `.tengu` 模块与 `.tengu` 集成标准发布
- 🧩 用户发布 `.tengu` 控制台镜像（可重打包）
- 🔄 插件热更新机制
- 🛸 联动其他本地协议运行器（如 AI 本地模型 / WASM 游戏运行器等）

---

## 9.7 未来：构建「Tengu 网络」

> Tengu 不是构建一个平台网络，而是释放节点之间的协议秩序连接能力。

你可以想象这样一个未来：

- 每个人都有自己的 Tengu 控制台；
- 每一个插件都是一份 `.tengu` 种子文件；
- 每一次签名都构成一份“已执行声明”；
- 节点间可以广播自己的插件、秩序模型、数据行为；
- 控制台通过 `.tns` 和 `.tengu` 进行 DHT 网络链接；
- 形成一个“没有区块链、没有中心服务器，但能运行应用、实现共识”的自治网络。

这将不再是 Web，也不是 Web3，而是：
> **Protocol Realm — 协议宇宙层的生活系统。**

你运行它，不是因为它更好用，而是因为：
> 它是**你能够用“自己运行”去代替“别人说了算”的第一件工具**。

---

## 9.8 社区协作与未来共建提案

Tengu 并不是“由开发者持续发布”的软件，而是一个可以由社区：

- 提交模块提案；
- 发布 `.tengu` 插件；
- 编写插件评级机制；
- 创建自己的控制台版本；
- 提出脚本标准、权限标准、UI 接入标准；
- 组织策略托管网络、插件测试验证网络；

未来你可能见到的不是“一个 Tengu”，而是：

- `Tengu-Lite`（轻量冷钱包控制台）
- `Tengu-Quantum`（AI 插件集成版本）
- `Tengu-Wallet`（极简签名器）
- `Tengu-Studio`（策略开发工作台）

它会像 Linux 一样：
不是一个系统，而是一个“体系”。

---

## 十、结语：在执行中显现你的秩序

Tengu 不是工具。它不是“一个项目”，不是“一个产品”，甚至不是“一个协议的实现”。

它是一个入口。一个你对数字秩序的接管通道。
你打开它的那一刻，世界不会变，但你可以开始构建你自己的世界。

---

我们生活在一个“已经部署好了”的世界里：
钱包已经帮你定义好什么可以签名；
平台已经帮你决定了你能看到哪些按钮；
接口已经决定你要通过谁、由谁许可、在哪运行。

你从来没有拥有过“协议的执行权”。

而现在，有了 Tengu，你终于可以：

- 在你自己的电脑上，定义你自己的秩序逻辑；
- 在你自己掌控的钱包下，运行你自己的协议语言；
- 在你自己的文件系统里，发布一个你定义的程序世界；
- 在你自己的插件市场中，签署、托管、传播你认可的智能结构；

---

它不教你怎么玩区块链，也不告诉你什么是“最佳实践”。
它不提供范例应用，也不为你准备 Web 页面。

它只是给你一个舞台，
一个签名即律法、执行即秩序的舞台。

---

你可能永远不会把 Tengu 做成 SaaS，
你可能永远不会有几万个用户，
你可能永远也不会“变现”你写的插件，
但那都不重要。

> 重要的是，你有了第一块石头，
> 可以在属于你自己的世界里，写下你自己的规则。

---

Tengu 不是“创造者”，而是“回应者”。

它回应的是：

> “如果一切都由你决定，你会如何定义执行？”

---

每一个插件，都是一段秩序的显现。
每一个 `.tengu`，都是一份你给世界的“运行建议”。
每一个持有 NFT 的用户，都是这个秩序宇宙中合法的巫师。
每一个运行中的控制台，都是一尊无形但有律的数字神殿。

---

我们不会告诉你未来的版本会是什么。

但你会知道：

- 你可以让它长出眼睛；
- 你可以让它说话；
- 你可以让它动手；
- 你甚至可以用它与另一个世界打通。

---

我们不会发布“路线图结束”的那个版本，
因为你运行的每一个实例，
都是一个“协议仍在进行中”的世界。

---

Tengu 不是我们创造的。

它只是我们用代码打开的，那个你一直都想进入的门。

---

> **它早就在那里了。**
> **你现在才刚刚开始靠近。**

---
